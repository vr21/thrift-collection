'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _package = require('../package.json');

var _package2 = _interopRequireDefault(_package);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _proxyUtil = require('./proxy-util');

var _proxyUtil2 = _interopRequireDefault(_proxyUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function concat(stream) {
  return new Promise(resolve => {
    let strings = [];
    stream.on('data', data => strings.push(data));
    stream.on('end', () => resolve(strings.join('')));
  });
}

/**
 * @typedef {Object} HTTPRequestOptions
 * @property {Object.<string, string>} headers - request headers
 * @property {string} method - request method (GET/POST/etc)
 * @property {(string)} body - request body. Sets content-type to application/json and stringifies when object
 * @property {(number)} port - port to use
 */


/**
 * Utility for simple HTTP calls
 * @class
 */
class HTTP {
  /**
   * make an http GET request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.get('https://google.com')
   * ```
   */
  static async get(url, options = {}) {
    options.method = 'GET';
    let http = new this(url, options);
    await http.request();
    return http.body;
  }

  /**
   * make an http POST request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.post('https://google.com')
   * ```
   */
  static async post(url, options = {}) {
    options.method = 'POST';
    let http = new this(url, options);
    await http.request();
    return http.body;
  }

  parseBody(body) {
    if (!this.headers['Content-Type']) {
      this.headers['Content-Type'] = 'application/json';
    }

    if (this.headers['Content-Type'] === 'application/json') {
      this.requestBody = JSON.stringify(body);
    } else {
      this.requestBody = body;
    }
    this.headers['Content-Length'] = Buffer.byteLength(this.requestBody).toString();
  }

  /**
   * make a streaming request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * let rsp = await http.get('https://google.com')
   * rsp.on('data', console.log)
   * ```
   */
  static async stream(url, options = {}) {
    options.method = 'GET';
    options.raw = true;
    let http = new this(url, options);
    await http.request();
    return http.response;
  }

  constructor(url, options = {}) {
    this.method = 'GET';
    this.host = 'localhost';
    this.port = 0;
    this.protocol = 'https:';
    this.path = '/';
    this.raw = false;
    this.headers = {
      'user-agent': `${_package2.default.name}/${_package2.default.version} node-${process.version}`
    };
    this.HTTPError = class HTTPError extends Error {

      constructor(http, body) {
        body = `\n${_util2.default.inspect(body)}`;
        super(`HTTP Error ${http.response.statusCode} for ${http.method} ${http.url}${body}`);
        this.statusCode = http.response.statusCode;
      }
    };

    if (!url) throw new Error('no url provided');
    let headers = Object.assign(this.headers, options.headers);
    Object.assign(this, options);
    this.headers = headers;
    let u = _url2.default.parse(url);
    this.protocol = u.protocol || this.protocol;
    this.host = u.hostname || this.host;
    this.port = u.port || this.port || (this.protocol === 'https:' ? 443 : 80);
    this.path = u.path || this.path;
    if (options.body) this.parseBody(options.body);
    this.body = undefined;
    if (_proxyUtil2.default.usingProxy) this.agent = _proxyUtil2.default.agent(u);
  }

  async request() {
    this.response = await this.performRequest();
    if (this.response.statusCode >= 200 && this.response.statusCode < 300) {
      if (!this.raw) this.body = await this.parse(this.response);
    } else throw new this.HTTPError(this, (await this.parse(this.response)));
  }

  get http() {
    return this.protocol === 'https:' ? _https2.default : _http2.default;
  }

  get url() {
    return `${this.protocol}//${this.host}${this.path}`;
  }

  performRequest() {
    return new Promise((resolve, reject) => {
      let request = this.http.request(this, resolve);
      request.on('error', reject);
      if (this.requestBody) request.write(this.requestBody);
      request.end();
    });
  }

  async parse(response) {
    let body = await concat(response);
    return response.headers['content-type'] === 'application/json' ? JSON.parse(body) : body;
  }

}
exports.default = HTTP;