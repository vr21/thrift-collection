'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ProxyUtil {
  static get httpProxy() {
    return process.env.HTTP_PROXY || process.env.http_proxy;
  }
  static get httpsProxy() {
    return process.env.HTTPS_PROXY || process.env.https_proxy;
  }

  static get usingProxy() {
    if (this.httpProxy || this.httpsProxy) return true;
    return false;
  }

  static findTunnel(urlParsed) {
    let tunnel = require('tunnel-agent');
    return urlParsed.protocol === 'https:' ? tunnel.httpsOverHttp : tunnel.httpOverHttp;
  }

  static findProxy(urlParsed) {
    if (urlParsed.protocol === 'https:') {
      return this.httpsProxy || this.httpProxy;
    } else {
      return this.httpProxy;
    }
  }

  static get sslCertDir() {
    const certDir = process.env.SSL_CERT_DIR;
    if (certDir) {
      const fs = require('fs');
      const path = require('path');
      return fs.readdirSync(certDir).map(f => path.join(certDir, f));
    } else {
      return [];
    }
  }

  static get sslCertFile() {
    return process.env.SSL_CERT_FILE ? [process.env.SSL_CERT_FILE] : [];
  }

  static get certs() {
    let filenames = this.sslCertFile.concat(this.sslCertDir);
    return filenames.map(function (filename) {
      const fs = require('fs');
      return fs.readFileSync(filename);
    });
  }

  static agent(urlParsed) {
    const u = this.findProxy(urlParsed);
    if (u) {
      let proxyParsed = _url2.default.parse(u);
      let tunnelMethod = this.findTunnel(urlParsed);
      let opts = {
        proxy: {
          host: proxyParsed.hostname,
          port: proxyParsed.port || '8080'
        }
      };

      if (proxyParsed.auth) {
        opts.proxy.proxyAuth = proxyParsed.auth;
      }

      if (this.certs.length > 0) {
        opts.ca = this.certs;
      }

      let tunnelAgent = tunnelMethod(opts);
      if (urlParsed.protocol === 'https:') {
        tunnelAgent.defaultPort = 443;
      }
      return tunnelAgent;
    }
  }
}
exports.default = ProxyUtil;